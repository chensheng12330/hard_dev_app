
keil C51语言编程如何缩减编译代码长度
2013年10月23日 16:38:02 少占鱼-正定 阅读数：856更多
个人分类： 我的自学实践
 
 
1、整形数字符做乘除法的C51程序，代码比较大。约9B左右，所以尽量不做乘除法。
       例如：uchar a=6；a=a*6；第二行代码要9个字节，而平时的语句只有2B。
2、定义变量的语句，不赋值或者不参与运算是不算代码的，能用短变量就用短变量，省RAM也省代码空间.
       例如：uchar a； 这句有没有代码长度不变。但是赋非0值 uchar  a=5；字符型，就要3B的代码长度。
       uint  a=5；整形变量赋值要6B字节，比较大，所以能定义短变量就定义短变量。
       unsigned  long int  a=6.0；或者 long int  a=6.0；会增加9B的代码。赋值整数浮点数一样。
3、对长整形变量，有符号变量比无符号变量 参与自加运算时编译的代码要长，所以尽量使用无符号浮点数
      例如：long  a=2； a++；或者unsinged long  int  a=2；a++； 代码要短15个字节。a--自减短12个字节
     自加换做加赋值则代码长无区别。a+=2；两种定义没区别。
4、浮点数不要作乘除法运算，代码长度太大。代码会长出几百字节。太得不偿失了。最好用其他方式代替。
5、对同一种类似操作，应该放在一起写。如数据的运算，如果中间调用子程序再回来运算，代码会长很多。（出出进进能不大吗）
6、定义变量时赋值，紧接着下条再赋值一次，会缩短代码。例如：uint  a=2； a=2； 多余一条反而缩短了代码。
       例如：uint  a=3，b=3；   a=b；  虽然是多余的，但是上一句代码消耗就抵消了。相当于没有增加任何代码。


优化级别说明（仅供参考）：
则其中的 Code Optimization    栏就是用来设置C51的优化级别。共有9个优化级别（书上这么写的），高优化级别中包含了前面所有的优化级别。现将各个级别说明如下：

0级优化：
1、 常数折叠：只要有可能，编译器就执行将表达式化为常数数字的计算，其中包括运行地址的计算。
2、 简单访问优化：对8051系统的内部数据和位地址进行访问优化。
3、 跳转优化：编译器总是将跳转延至最终目标上，因此跳转到跳转之间的命令被删除。
1级优化：
1、 死码消除：无用的代码段被消除。
2、 跳转否决：根据一个测试回溯，条件跳转被仔细检查，以决定是否能够简化或删除。
2级优化：
1、 数据覆盖：适于静态覆盖的数据和位段被鉴别并标记出来。连接定位器BL51通过对全局数据流的分析，选择可静态覆盖的段。
3级优化：
1、“窥孔”优化：将冗余的MOV命令去掉，包括不必要的从存储器装入对象及装入常数的操作。另外如果能节省存储空间或者程序执行时间，复杂操作将由简单操作所代替。
4级优化：
1、 寄存器变量：使自动变量和函数参数尽可能位于工作寄存器中，只要有可能，将不为这些变量保留数据存储器空间。
2、扩展访问优化：来自IDATA、XDATA、PDATA和CODE区域的变量直接包含在操作之中，因此大多数时候没有必要将其装入中间寄存器。
3、局部公共子式消除：如果表达式中有一个重复执行的计算，第一次计算的结果被保存，只要有可能，将被用作后续的计算，因此可从代码中消除繁杂的计算。
4、 CASE/SWITCH语句优化：将CASE/SWITCH语句作为跳转表或跳转串优化。
5级优化：
1、 全局公共子式消除：只要有可能，函数内部相同的子表达式只计算一次。中间结果存入一个寄存器以代替新的计算。
2、 简单循环优化：以常量占据一段内存的循环再运行时被优化。
6级优化：
1、 回路循环：如果程序代码能更快更有效地执行，程序回路将进行循环。
7级优化：
1、 扩展入口优化：在适合时对寄存器变量使用DPTR数据指针，指针和数组访问被优化以减小程序代码和提高执行速度。
8级优化：
1、 公共尾部合并：对同一个函数有多处调用时，一些设置代码可被重复使用，从而减小程序代码长度。
9级优化：
1、 公共子程序块：检测重复使用的指令序列，并将它们转换为子程序。C51甚至会重新安排代码以获得更多的重复使用指令序列。
当然，优化级别并非越高越好，应该根据具体要求适当选择。

事实上每个C文件都可以有独立的优化级别的：

在工作区右键选择你的模块（.C）然后选取Options for File xxx就会出现如下界面:


在C51选项中就可以选择优化级别和警告级别等东西了,被独立设置过的C文件会有特殊的标记的：


用以提醒你这个文件的编译处理并非默认设置！
如果你觉得模块优化都不够细的话,你可以考虑局部优化,也就是说对某个函数实行某个级别的优化。当你发现9级优化的时候某个函数总是变的不正常,但你又希望其它函数和程序段保持最高的简洁度,那么局部优化可以说是相当有用的了。在KEIL手册中有介绍这个功能：
#pragma OPTIMIZE(x) x就是你希望的优化级别,一般应用如下：

#pragma OPTIMIZE(6)
void FunA()
{
}
......
......

#pragma OPTIMIZE(9)
void FunB()
{
}

上面的意思就是说,在void FunA()到void FunB()之前的所有函数,包括FunA在内,都采用6级的优化,而从FunB开始直到之后,只要没碰上#pragma OPTIMIZE,都采用9级优化了。
OPTIMIZE还可以多一个参数,就是speed和size,
用法： #pragma OPTIMIZE(9,speed)或#pragma OPTIMIZE(5,size）
对应的就是9级优化,以速度为主,或5级优化,以空间最小为主。

4.StartUp.a51
在之前第一节的建立工程中就曾经提到过StartUp.a51这个东西了,就是在工程初建的时候有个对话框用于选择是否为工程添加这个a51文件。


其实这个文件给大家最最深刻的感觉就是：开机清空RAM。事实上它还有其他特别的用途的,例如初始化堆栈（很多人不知道KEILC一开始把堆栈设定为多少,事实上可以通过软件仿真的时候从这个文件找到答案）,然后是再入函数的虚拟堆栈的设置,还有更高级一点的,BANK的初始化。
旧版本KEIL自动为每个工程默认添加相同的StartUp文件,后期的KEIL就有了上图的选择,如果选择添加,则会为每个工程添加一个独立的StartUp。用户可以通过手工改写StartUp.a51实现某些必要的上电初始化。例如最通常的：取消单片机开机清RAM功能